# Sudoku(数独)
|  |一|二|三|四|五|六|七|八|九|
|---|---|---|---|---|---|---|---|---|---|
|一|1	|	|4	|	|	|	|	|	|	|
|二|	|	|	|	|	|5	|	|	|	|
|三|	|6	|	|	|8	|	|	|7	|3	|
|四|	|	|	|8	|	|1	|9	|	|	|
|五|6	|5	|	|	|	|	|	|	|	|
|六|	|	|	|3	|	|	|	|	|8	|
|七|	|2	|	|	|3	|	|	|	|7	|
|八|	|	|	|	|	|7	|1	|3	|	|
|九|4	|7	|	|	|	|	|8	|9	|	|

数独是一种填数字游戏，共有9行，9列，81个数字。每9个数字聚合在一起形成一组，所以共有9组。   
游戏规则：用9组1到9的数字依次填入每个单元格内，要求每行，每列，每组不能有重复的数字。

## 简介
此程序是数独的推导程序，使用方法是在`SudokuBootstrap`中，将81个数字依次录入`total`集合内，其中待推导的数字为0，然后执行`main`方法。  	
程序采用的数据结构是二叉树，图示如下：
```
                                          ROOT(0,0,0,0)
                                            /       \
                                Sudoku(1,1,1,1)     Sudoku(1,2,1,1)
                                    /       \
                        Sudoku(4,1,4,2)   Sudoku(4,3,4,2)
```
所属类为`SudokuTree`，其中推导链`sudokuChain`记录了二叉树中当前推导链上的所有节点信息，`chainMap`记录了由推导链节点推导出的全部数独信息。

在推导时，会对全部的可能情况进行遍历，这样会导致一个问题，即如果某一个假定的数字是错误的（第一次概率为½，后续为(½)的n次方），将导致后续全部的推导无效，会浪费大量时间。
所以用`chainLoopCounter`对某个节点的循环次数做了限制，次数限制因子`LOOP_FACTOR`为50，如果这个数字过小，会使循环提前结束，无法推导出正确结果。
如果数字过大，又会出现程序长时间运行无法终止的情况。 

推导的主要方法是`SudokuCalculator.reasoning`,运行过程为：

首先假定二叉树中左子树的值为真，然后查找全部受此值影响的单个数字，如果存在则重复循环，如果不存在则寻找其他的二元信息，在此节点上延长二叉树
并循环上一流程，左子树循环结束后切换至右子树，右子树循环完成后，切换至父节点，以其他二元信息重新延长父节点，如果该父节点下的全部二元信息均已遍历，
则会切换至父节点的右节点。

临界情况1：在推导过程中发现错误，由于无法断定错误信息究竟由哪一次推导引起，所以会继续循环。

临界情况2：假定某个节点值为真时，既无法查找出任何受影响的单个数字，也无法查找出任何受影响的二元信息，此种情况下，会保持该节点值为真的情况，并延伸二叉树。

临界情况3：全部结果推导完成，程序终止。

上面布局的推导结果为：

|  |一|二|三|四|五|六|七|八|九|
|---|---|---|---|---|---|---|---|---|---|
|一|1	|8	|4	|2	|7	|3	|5	|6	|9	|
|二|7	|3	|9	|6	|4	|5	|2	|8	|1	|
|三|2	|6	|5	|1	|8	|9	|4	|7	|3	|
|四|3	|4	|7	|8	|5	|1	|9	|2	|6	|
|五|6	|5	|8	|7	|9	|2	|3	|1	|4	|
|六|9	|1	|2	|3	|6	|4	|7	|5	|8	|
|七|5	|2	|1	|9	|3	|8	|6	|4	|7	|
|八|8	|9	|6	|4	|2	|7	|1	|3	|5	|
|九|4	|7	|3	|5	|1	|6	|8	|9	|2	|
